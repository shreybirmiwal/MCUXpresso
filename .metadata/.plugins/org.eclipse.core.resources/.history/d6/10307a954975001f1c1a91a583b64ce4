/*
 * Copyright 2018 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#if (__ARM_FEATURE_CMSE & 1) == 0
#error "Need ARMv8-M security extensions"
#elif (__ARM_FEATURE_CMSE & 2) == 0
#error "Compile with --cmse"
#endif

#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "arm_cmse.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "board.h"
#include "veneer_table.h"
#include "tzm_config.h"
#include "tzm_api.h"

#include "fsl_power.h"

// Include for cryptographic functions
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/ecdsa.h"
#include "mbedtls/ecp.h"
#include "mbedtls/sha256.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define DEMO_CODE_START_NS 0x00010000
#define NON_SECURE_START DEMO_CODE_START_NS

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/
/*!
 * @brief Application-specific implementation of the SystemInitHook() weak function.
 */

int random_num(void) __attribute__((cmse_nonsecure_entry));

void SystemInitHook(void)
{
    /* The TrustZone should be configured as early as possible after RESET.
     * Therefore it is called from SystemInit() during startup. The SystemInitHook() weak function
     * overloading is used for this purpose.
     */
    BOARD_InitTrustZone();
}

int random_num(void) {
    return rand();
}

/*!
 * @brief Function to sign data using ECDSA with secp256r1
 */
int sign_data_ecdsa(unsigned char *data, size_t data_len, unsigned char *signature, size_t *sig_len) {
    int ret;
    mbedtls_ecp_group grp;
    mbedtls_mpi d;           // Private key
    mbedtls_ecp_point Q;      // Public key
    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    unsigned char hash[32];   // SHA-256 hash of the data

    const char *pers = "ecdsa_sign";

    // Initialize contexts
    mbedtls_ecp_group_init(&grp);
    mbedtls_mpi_init(&d);
    mbedtls_ecp_point_init(&Q);
    mbedtls_entropy_init(&entropy);
    mbedtls_ctr_drbg_init(&ctr_drbg);

    // Seed the random number generator
    if ((ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, (const unsigned char *)pers, strlen(pers))) != 0) {
        PRINTF("Failed to initialize random generator - code %d\r\n", ret);
        return ret;
    }

    // Load the secp256r1 (NIST P-256) curve
    if ((ret = mbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_SECP256R1)) != 0) {
        PRINTF("Failed to load curve - code %d\r\n", ret);
        return ret;
    }

    // Generate a key pair
    if ((ret = mbedtls_ecp_gen_keypair(&grp, &d, &Q, mbedtls_ctr_drbg_random, &ctr_drbg)) != 0) {
        PRINTF("Failed to generate key pair - code %d\r\n", ret);
        return ret;
    }

    // Hash the data using SHA-256
    mbedtls_sha256(data, data_len, hash, 0);  // 0 means standard SHA-256, not SHA-224

    // Sign the hash
    mbedtls_mpi r, s;
    mbedtls_mpi_init(&r);
    mbedtls_mpi_init(&s);

    if ((ret = mbedtls_ecdsa_sign(&grp, &r, &s, &d, hash, sizeof(hash), mbedtls_ctr_drbg_random, &ctr_drbg)) != 0) {
        PRINTF("Failed to sign data - code %d\r\n", ret);
        return ret;
    }

    // Write the signature to the buffer (r and s concatenated)
    if ((ret = mbedtls_mpi_write_binary(&r, signature, 32)) != 0 || (ret = mbedtls_mpi_write_binary(&s, signature + 32)) != 0) {
        PRINTF("Failed to write signature - code %d\r\n", ret);
        return ret;
    }

    *sig_len = 64; // ECDSA signature is 64 bytes for secp256r1 (32 bytes for r and 32 bytes for s)

    // Free contexts
    mbedtls_mpi_free(&r);
    mbedtls_mpi_free(&s);
    mbedtls_ecp_group_free(&grp);
    mbedtls_mpi_free(&d);
    mbedtls_ecp_point_free(&Q);
    mbedtls_ctr_drbg_free(&ctr_drbg);
    mbedtls_entropy_free(&entropy);

    return 0;
}

/*!
 * @brief Main function
 */
int main(void)
{
    /* Init board hardware. */
    /* set BOD VBAT level to 1.65V */
    POWER_SetBodVbatLevel(kPOWER_BodVbatLevel1650mv, kPOWER_BodHystLevel50mv, false);
    /* attach main clock divide to FLEXCOMM0 (debug console) */
    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);

    BOARD_InitPins();
    BOARD_BootClockPLL150M();
    BOARD_InitDebugConsole();

    PRINTF("SecureWorld:Generating Random benchmarking test # (unpredictable by nonsecure..)\r\n");
    int randomValue = random_num();
    PRINTF("Random#: : %d\r\n", randomValue);
    PRINTF("Sending test to nonsecure (CPU/GPU cluster)\r\n");

    /* Call non-secure application - jump to normal world */
    //    TZM_JumpToNormalWorld(NON_SECURE_START);

    int result = 1;
    //    int result = process_test_case_ns(randomValue);
    PRINTF("Test case result from non-secure world (DUMMY/FAKE): %d\r\n", result);

    // Sign the result with ECDSA using secp256r1
    unsigned char signature[64];
    size_t sig_len = 0;
    unsigned char data_to_sign[sizeof(result)];
    memcpy(data_to_sign, &result, sizeof(result));

    if (sign_data_ecdsa(data_to_sign, sizeof(result), signature, &sig_len) == 0) {
        PRINTF("Successfully signed the result with ECDSA\r\n");
        PRINTF("Signature (hex): ");
        for (size_t i = 0; i < sig_len; i++) {
            PRINTF("%02x", signature[i]);
        }
        PRINTF("\r\n");
    } else {
        PRINTF("Failed to sign the result\r\n");
    }

    while (1)
    {
        /* This point should never be reached */
    }
}
